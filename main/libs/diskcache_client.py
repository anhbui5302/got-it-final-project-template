"""
This module adds the functionalities to manage data stored
in a node-local cache.

We have some data that are too large to store in memcache, so we
need to implement a node-local caching mechanism using diskcache.
At the time of writing this module, we need to cache PFD session
data, which can be in the range of 50-100 MB.

Data stored in diskcache is node-local, i.e., there can be multiple
versions of the data across nodes. Therefore, we need a way to know
that the node-local data is the latest version. If not, we ignore
the cached data in the node-local cache as if it is not stored.

Whether the node-local data is latest or not can be verified by
storing the timestamp of when the data is stored in both global
(memcached) and local cache. When getting the data, first we need
to check if the local updated timestamp is the same as the global
updated timestamp:
- If they are the same, then the node-local data is latest and we
  can return it directly.
- Otherwise, we remove the stored data in the node-local cache and
  return None as if the data is not stored.

One caveat: The timestamps generated by different nodes can be different,
even if they are generated exactly at a same global moment. However,
the differences are negligible since there won't be many concurrent
data handling processes.
"""

import time

import diskcache
from memcache import Client as MemcacheClient

from main.libs.log import ServiceLogger

logger = ServiceLogger(__name__)


class DiskcacheClient:
    def __init__(
        self,
        directory: str,
        size_limit: int,
        memcache_client: MemcacheClient,
    ):
        self._client = diskcache.FanoutCache(
            directory=directory,
            size_limit=size_limit,
            eviction_policy='least-recently-used',
            timeout=1,
        )
        self._memcache_client = memcache_client

    def get(self, key: str):
        logger.debug(message=f'Start getting {key}')

        updated_timestamp_cache_key = _get_updated_timestamp_cache_key(key)
        global_updated_timestamp = self._memcache_client.get(
            updated_timestamp_cache_key
        )
        local_updated_timestamp = self._client.get(updated_timestamp_cache_key)

        # Check if global and local updated_timestamp match
        if (
            global_updated_timestamp is None
            or local_updated_timestamp is None
            or local_updated_timestamp != global_updated_timestamp
        ):
            logger.warning(
                message='Global and local updated_timestamp mismatch',
                data={
                    'global_updated_timestamp': global_updated_timestamp,
                    'local_updated_timestamp': local_updated_timestamp,
                },
            )

            self._client.delete(key)
            self._client.delete(updated_timestamp_cache_key)
            return None

        cached_data = self._client.get(key)
        if cached_data is not None:
            logger.debug(
                message='Diskcache hit',
                data={
                    'key': key,
                    'size': _get_value_size(cached_data),
                },
            )
        else:
            logger.debug(
                message='Diskcache miss',
                data={
                    'key': key,
                },
            )

        return cached_data

    def set(self, key: str, value, expire=None) -> bool:
        logger.debug(message=f'Start setting {key}, size {_get_value_size(value)}')

        # Store the value in node-local cache
        is_success = self._client.set(
            key=key,
            value=value,
            expire=expire,
        )

        if is_success:
            logger.debug(
                message='Data stored in diskcache',
                data={
                    'key': key,
                },
            )

            # Update the updated_timestamp in both global and node-local cache
            updated_timestamp_cache_key = _get_updated_timestamp_cache_key(key)
            updated_timestamp = time.time_ns()
            self._memcache_client.set(
                key=updated_timestamp_cache_key,
                val=updated_timestamp,
                time=expire or 0,
            )
            self._client.set(
                key=updated_timestamp_cache_key,
                value=updated_timestamp,
                expire=expire,
            )
        else:
            logger.warning(
                message='Fail to store data in diskcache',
                data={
                    'key': key,
                },
            )

        logger.debug(message=f'Finish setting {key}')

        return is_success

    def delete(self, key: str) -> bool:
        if key not in self._client:
            return False

        is_success = self._client.delete(key)

        if is_success:
            logger.debug(
                message='Data deleted from diskcache',
                data={
                    'key': key,
                },
            )

            updated_timestamp_cache_key = _get_updated_timestamp_cache_key(key)
            self._memcache_client.delete(updated_timestamp_cache_key)
            self._client.delete(updated_timestamp_cache_key)
        else:
            logger.warning(
                message='Fail to delete data from diskcache',
                data={
                    'key': key,
                },
            )

        return is_success

    def clear(self):
        self._client.clear()


def _get_updated_timestamp_cache_key(key: str) -> str:
    return f'{key}:updated'


def _get_value_size(value) -> int:
    try:
        return len(value)
    except TypeError:
        return 0
